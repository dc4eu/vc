package openid4vci

import (
	"encoding/json"
	"errors"
	"io"
	"net/url"
)

// AuthorizationDetailsParameter https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html#name-using-authorization-details
type AuthorizationDetailsParameter struct {
	Type string `json:"type" form:"type" validate:"required,oneof=openid_credential"`

	//CredentialConfigurationID: REQUIRED when format parameter is not present. String specifying a unique identifier of the Credential being described in the credential_configurations_supported map in the Credential Issuer Metadata as defined in Section 11.2.3. The referenced object in the credential_configurations_supported map conveys the details, such as the format, for issuance of the requested Credential. This specification defines Credential Format specific Issuer Metadata in Appendix A. It MUST NOT be present if format parameter is present.
	CredentialConfigurationID string `json:"credential_configuration_id,omitempty" form:"credential_configuration_id" validate:"required_without=Format"`

	// Format REQUIRED when credential_configuration_id parameter is not present. String identifying the format of the Credential the Wallet needs. This Credential format identifier determines further claims in the authorization details object needed to identify the Credential type in the requested format. This specification defines Credential Format Profiles in Appendix A. It MUST NOT be present if credential_configuration_id parameter is present.
	Format string `json:"format,omitempty" form:"format" validate:"required_without=CredentialConfigurationID"`

	// VCT REQUIRED. String as defined in Appendix A.3.2. This claim contains the type values the Wallet requests authorization for at the Credential Issuer. It MUST only be present if the format claim is present. It MUST not be present otherwise.
	VCT string `json:"vct,omitempty" form:"vct" validate:"required_with=Format"`

	// Claims OPTIONAL. Object as defined in Appendix A.3.2 excluding the display and value_type parameters. mandatory parameter here is used by the Wallet to indicate to the Issuer that it only accepts Credential(s) issued with those claim(s).
	Claims map[string]any `json:"claims,omitempty" form:"claims"`
}

// PARRequest https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html#RFC6749
type PARRequest struct {
	// RFC 6749#4.1.1
	ResponseType string `form:"response_type" json:"response_type" validate:"required,oneof=code"`
	ClientID     string `json:"client_id" form:"client_id" validate:"required"`
	RedirectURI  string `json:"redirect_uri" form:"redirect_uri" validate:"required"`
	Scope        string `json:"scope" form:"scope"`
	State        string `json:"state" form:"state"`

	AuthorizationDetails []AuthorizationDetailsParameter `json:"authorization_details" mura:"authorization_details"`
	CodeChallenge        string                          `json:"code_challenge" form:"code_challenge" validate:"required"`
	CodeChallengeMethod  string                          `json:"code_challenge_method" form:"code_challenge_method" validate:"required,oneof=S256 plain"`

	// https://openid.net/specs/openid-4-verifiable-credential-issuance-1_0.html#name-additional-request-paramete
	WalletIssuer string `json:"wallet_issuer" form:"wallet_issuer"`
	UserHint     string `json:"user_hint" form:"user_hint"`
	IssuingState string `json:"issuing_state" form:"issuing_state"`
}

type ParResponse struct {
	// RequestURI : The request URI corresponding to the authorization request posted. This URI is used as reference to the respective request data in the subsequent authorization request only. The way the authorization process obtains the authorization request data is at the discretion of the authorization server and out of scope of this specification. There is no need to make the authorization request data available to other parties via this URI.
	RequestURI string `json:"request_uri" form:"request_uri" validate:"required"`

	// ExpiresIn : A JSON number that represents the lifetime of the request URI in seconds. The request URI lifetime is at the discretion of the authorization server and will typically be relatively short.
	ExpiresIn int `json:"expires_in" form:"expires_in" validate:"required"`
}

type AuthorizeRequest struct {
	ClientID   string `json:"client_id" uri:"client_id" form:"client_id" validate:"required"`
	RequestURI string `json:"request_uri" uri:"request_uri" form:"request_uri" validate:"required"`
}

// AuthorizationResponse RFC6749#4.1.2
type AuthorizationResponse struct {
	//	REQUIRED.  The authorization code generated by the
	//	authorization server.  The authorization code MUST expire
	//	shortly after it is issued to mitigate the risk of leaks.  A
	//	maximum authorization code lifetime of 10 minutes is
	//	RECOMMENDED.  The client MUST NOT use the authorization code
	//
	//	more than once.  If an authorization code is used more than
	//	once, the authorization server MUST deny the request and SHOULD
	//	revoke (when possible) all tokens previously issued based on
	//	that authorization code.  The authorization code is bound to
	//	the client identifier and redirection URI.
	Code string `json:"code" validate:"required"`

	// State REQUIRED if the "state" parameter was present in the client authorization request.  The exact value received from the client.
	State string `json:"state" validate:"required"`
}

// BindAuthorizationRequest binds the AuthorizationRequest
func BindAuthorizationRequest(body io.ReadCloser) (*PARRequest, error) {
	if body == nil {
		return nil, errors.New("no_body")
	}

	authorizationRequest := &PARRequest{}

	v := map[string]any{}

	err := json.NewDecoder(body).Decode(&v)
	if err != nil {
		return nil, err
	}

	details, ok := v["authorization_details"]
	if ok {
		d := details.(string)
		delete(v, "authorization_details")

		decodedAuthorizationDetails, err := url.QueryUnescape(d)
		if err != nil {
			return nil, err
		}

		if err = json.Unmarshal([]byte(decodedAuthorizationDetails), &authorizationRequest.AuthorizationDetails); err != nil {
			return nil, err
		}
	}

	b, err := json.Marshal(v)
	if err != nil {
		return nil, err
	}

	if err = json.Unmarshal(b, authorizationRequest); err != nil {
		return nil, err
	}

	return authorizationRequest, nil
}
