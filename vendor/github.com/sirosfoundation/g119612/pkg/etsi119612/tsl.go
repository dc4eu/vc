//The etsi119612 package implements ETSI 119 612 trust status list. The package is
//primarily meant to be used to create a CertPool for [crypto/x509] Certificate
//validation. The package provides some small number of utilities for introspecting
//trust status lists.

package etsi119612

import (
	"bytes"
	"context"
	"crypto/x509"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	log "github.com/sirupsen/logrus"

	"strings"

	"github.com/moov-io/signedxml"
)

// A representation of an ETSI 119 612 trust status list. The main struct type StatusList
// is autogenerated from the v2 XML Schema definition.
type TSL struct {
	StatusList TrustStatusListType `xml:"tsl:TrustServiceStatusList"`
	Source     string
	Signed     bool
	Signer     x509.Certificate
	Referenced []*TSL
}

func (tsl *TSL) NumberOfTrustServiceProviders() int {
	if tsl == nil || tsl.StatusList.TslTrustServiceProviderList == nil {
		return 0
	}
	return len(tsl.StatusList.TslTrustServiceProviderList.TslTrustServiceProvider)
}

func (tsl *TSL) SchemeOperatorName() string {
	if tsl == nil || tsl.StatusList.TslSchemeInformation == nil {
		return "Unknown scheme operator"
	}
	return FindByLanguage(tsl.StatusList.TslSchemeInformation.TslSchemeOperatorName, "en", "Unknown scheme operator")
}

func (tsl *TSL) String() string {
	if tsl == nil {
		return "<nil TSL>"
	}
	return fmt.Sprintf("TSL[Source: %s] by %s with %d trust service providers", tsl.Source, tsl.SchemeOperatorName(), tsl.NumberOfTrustServiceProviders())
}

// CleanCerts trims whitespace from all certificates in the TSL.
func (tsl *TSL) CleanCerts() {
	tsl.WithTrustServices(func(tsp *TSPType, svc *TSPServiceType) {
		if svc.TslServiceInformation != nil && svc.TslServiceInformation.TslServiceDigitalIdentity != nil {
			for i := range svc.TslServiceInformation.TslServiceDigitalIdentity.DigitalId {
				cert := svc.TslServiceInformation.TslServiceDigitalIdentity.DigitalId[i].X509Certificate
				svc.TslServiceInformation.TslServiceDigitalIdentity.DigitalId[i].X509Certificate = strings.TrimSpace(cert)
			}
		}
	})
}

// TSLFetchOptions defines configurable options for fetching Trust Service Lists.
// It allows controlling HTTP request parameters like User-Agent and timeout.
//
// The options provide control over:
//   - The User-Agent header sent with HTTP requests
//   - The timeout for HTTP connections and requests
//   - Using a custom HTTP client for more advanced configuration
//   - The maximum depth for dereferencing pointers to other TSLs
//
// For most cases, the DefaultTSLFetchOptions provide reasonable settings.
type TSLFetchOptions struct {
	// UserAgent is the User-Agent header to use for HTTP requests.
	// A descriptive User-Agent helps server administrators identify client applications
	// and can prevent blocking of requests that don't identify themselves.
	UserAgent string

	// Timeout is the maximum time to wait for an HTTP request to complete.
	// This helps prevent applications from hanging indefinitely when servers are
	// unresponsive or connections are slow.
	Timeout time.Duration

	// Client is a custom HTTP client to use instead of the default one.
	// If provided, the Timeout option is ignored as the client should be
	// configured with the desired timeout and other settings.
	// Use this for advanced scenarios like custom TLS configuration or proxies.
	Client *http.Client

	// MaxDereferenceDepth controls how many levels of TSL references are followed.
	// A value of 0 means no references are followed.
	// A value of -1 means follow references without a limit (be careful with this).
	// Any positive value limits the depth of reference traversal.
	MaxDereferenceDepth int

	// AcceptHeaders defines the Accept header(s) to send with HTTP requests.
	// This helps with content negotiation to ensure we receive XML content.
	// If empty, a default set of XML-related Accept headers will be used.
	AcceptHeaders []string
}

// DefaultTSLFetchOptions provides reasonable default options for fetching TSLs
var DefaultTSLFetchOptions = TSLFetchOptions{
	UserAgent:           "Go-Trust/1.0 TSL Fetcher (+https://github.com/sirosfoundation/go-trust)",
	Timeout:             30 * time.Second,
	MaxDereferenceDepth: 3,                                                                                                // Follow references up to 3 levels deep by default
	AcceptHeaders:       []string{"application/xml", "text/xml", "application/xhtml+xml", "text/html;q=0.9", "*/*;q=0.8"}, // Prefer XML content
}

// FetchTSL creates a TSL object from a URL. The URL is fetched with [net/http], parsed and unmarshalled
// into the object structure. This function uses DefaultTSLFetchOptions and automatically dereferences
// pointers to other TSLs.
//
// For more control over HTTP parameters and dereferencing behavior, use FetchTSLWithOptions.
//
// Returns the root TSL only. For accessing referenced TSLs, use FetchTSLWithAllReferences.
func FetchTSL(url string) (*TSL, error) {
	tsls, err := FetchTSLWithReferencesAndOptions(url, DefaultTSLFetchOptions)
	if err != nil {
		return nil, err
	}
	if len(tsls) == 0 {
		return nil, fmt.Errorf("no TSLs returned")
	}
	return tsls[0], nil
}

// FetchTSLWithAllReferences fetches a TSL and all its referenced TSLs using default options.
// This returns all TSLs in a slice, with the root TSL being the first element.
//
// Parameters:
//   - url: The URL to fetch the TSL from
//
// Returns:
//   - A slice containing the root TSL and all referenced TSLs
//   - Any error that occurred during fetching
func FetchTSLWithAllReferences(url string) ([]*TSL, error) {
	return FetchTSLWithReferencesAndOptions(url, DefaultTSLFetchOptions)
}

// FetchTSLWithOptions creates a TSL object from a URL with custom fetch options.
// The URL is fetched with [net/http] using the provided options, parsed and unmarshalled
// into the object structure.
//
// Unlike FetchTSL, this function does not automatically dereference pointers to other TSLs.
// To fetch a TSL and all its referenced TSLs with the same options, use FetchTSLWithReferencesAndOptions.
//
// Parameters:
//   - url: The URL to fetch the TSL from (supports file:// URLs for local files)
//   - options: Options controlling HTTP request parameters
//
// Returns:
//   - A pointer to the fetched and parsed TSL
//   - Any error that occurred during fetching or parsing
func FetchTSLWithOptions(url string, options TSLFetchOptions) (*TSL, error) {
	var bodyBytes []byte
	var err error
	if strings.HasPrefix(url, "file://") {
		path := strings.TrimPrefix(url, "file://")
		bodyBytes, err = os.ReadFile(path)
		if err != nil {
			return nil, err
		}
	} else {
		// Create an HTTP client with the specified timeout
		client := options.Client
		if client == nil {
			client = &http.Client{
				Timeout: options.Timeout,
			}
		}

		// Create request with context
		ctx, cancel := context.WithTimeout(context.Background(), options.Timeout)
		defer cancel()

		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			return nil, err
		}

		// Set User-Agent header
		req.Header.Set("User-Agent", options.UserAgent)

		// Set Accept headers for content negotiation
		if len(options.AcceptHeaders) > 0 {
			req.Header.Set("Accept", strings.Join(options.AcceptHeaders, ", "))
		}

		// Execute request
		resp, err := client.Do(req)
		if err != nil {
			return nil, err
		}
		defer resp.Body.Close()

		// Check response status
		if resp.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("unexpected HTTP status: %s", resp.Status)
		}

		bodyBytes, err = io.ReadAll(resp.Body)
		if err != nil {
			return nil, err
		}
	}
	t := TSL{Source: url, StatusList: TrustStatusListType{}}
	log.Debugf("g119612: Fetched %d bytes from %s\n", len(bodyBytes), url)

	if bytes.Contains(bodyBytes, []byte("Signature>")) {
		t.Signed = true
		// lets try to validate a signature if we can
		validator, err := signedxml.NewValidator(string(bodyBytes))
		if err == nil {
			validator.SetReferenceIDAttribute("Id")
			xml, err := validator.ValidateReferences()
			if err == nil {
				bodyBytes = []byte(xml[0])
				t.Signer = validator.SigningCert()
			} else {
				return nil, err
			}
		} else {
			return nil, err
		}
	}

	err = xml.Unmarshal(bodyBytes, &t.StatusList)
	if err != nil {
		return nil, err
	}

	t.CleanCerts()

	// Don't automatically dereference pointers here - that will be done by the caller if needed

	log.Infof("g119612: Parsed TSL from %s with %d trust service providers\n", url, t.NumberOfTrustServiceProviders())

	return &t, nil
}

func (tsl *TSL) AddReferencedTSL(ref *TSL) {
	if tsl.Referenced == nil {
		tsl.Referenced = []*TSL{}
	}
	tsl.Referenced = append(tsl.Referenced, ref)
}

// FetchTSLWithReferencesAndOptions fetches a TSL and all its referenced TSLs with the specified options.
// This is a convenience function that combines FetchTSLWithOptions and dereferencePointersToOtherTSLWithOptions.
// The depth of dereferencing is controlled by options.MaxDereferenceDepth.
//
// Parameters:
//   - url: The URL to fetch the TSL from
//   - options: Options controlling HTTP request parameters and dereferencing depth
//
// Returns:
//   - A slice containing the fetched TSL and all its referenced TSLs (if any)
//   - Any error that occurred during fetching or parsing the root TSL
//
// The first element in the returned slice is always the root TSL. Any referenced TSLs
// that were successfully fetched follow in the slice. This allows callers to process
// both the root TSL and all its references without having to traverse the reference tree.
func FetchTSLWithReferencesAndOptions(url string, options TSLFetchOptions) ([]*TSL, error) {
	root, err := FetchTSLWithOptions(url, options)
	if err != nil {
		return nil, err
	}

	// If depth is 0, don't follow references at all
	if options.MaxDereferenceDepth == 0 {
		return []*TSL{root}, nil
	}

	// Collect all TSLs (root + referenced) using a map to avoid duplicates
	allTSLs := make(map[string]*TSL)
	allTSLs[url] = root

	// Dereference pointers with the specified depth
	if err := root.dereferencePointersTSLsRecursive(options, allTSLs, 1); err != nil {
		// Log the error but continue - we still return what we have
		log.Warnf("g119612: Error while dereferencing TSL pointers: %v", err)
	}

	// Convert map to slice, ensuring the root TSL is first
	result := make([]*TSL, 0, len(allTSLs))
	result = append(result, root)

	for urlKey, tsl := range allTSLs {
		if urlKey != url { // Skip the root which we already added
			result = append(result, tsl)
		}
	}

	return result, nil
}

// DereferencePointersToOtherTSL fetches and adds all referenced TSLs using default options.
// This examines the TSL for pointers to other TSLs (TslPointersToOtherTSL) and fetches each
// of them using the default fetch options.
func (tsl *TSL) DereferencePointersToOtherTSL() {
	tsl.dereferencePointersToOtherTSLWithOptions(DefaultTSLFetchOptions)
}

// dereferencePointersToOtherTSLWithOptions fetches and adds referenced TSLs using the provided fetch options.
//
// This method examines the TSL for pointers to other TSLs (TslPointersToOtherTSL) and fetches each
// of them using the specified options. Successfully fetched TSLs are added to the Referenced list.
// Failures to fetch referenced TSLs are logged but do not cause this method to return an error.
//
// Parameters:
//   - options: The options to use when fetching referenced TSLs
func (tsl *TSL) dereferencePointersToOtherTSLWithOptions(options TSLFetchOptions) {
	if tsl.StatusList.TslSchemeInformation == nil || tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL == nil {
		return
	}
	for _, p := range tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL.TslOtherTSLPointer {
		refTsl, err := FetchTSLWithOptions(p.TSLLocation, options)
		if err == nil {
			tsl.AddReferencedTSL(refTsl)
		} else {
			log.Warnf("g119612: Failed to fetch referenced TSL %s: %v", p.TSLLocation, err)
		}
	}
}

// dereferencePointersTSLsRecursive fetches referenced TSLs recursively up to the specified depth.
// This is a helper method used by FetchTSLWithReferencesAndOptions to recursively follow references.
//
// Parameters:
//   - options: Options controlling HTTP request parameters
//   - allTSLs: Map to store all fetched TSLs by URL
//   - currentDepth: Current depth of recursion
//
// Returns:
//   - Any error that occurred during fetching
func (tsl *TSL) dereferencePointersTSLsRecursive(options TSLFetchOptions, allTSLs map[string]*TSL, currentDepth int) error {
	// Check if we've reached the maximum depth
	if options.MaxDereferenceDepth > 0 && currentDepth > options.MaxDereferenceDepth {
		return nil
	}

	// Skip if there are no pointers to other TSLs
	if tsl.StatusList.TslSchemeInformation == nil || tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL == nil {
		return nil
	}

	// Process each pointer
	for _, p := range tsl.StatusList.TslSchemeInformation.TslPointersToOtherTSL.TslOtherTSLPointer {
		// Skip if we've already fetched this TSL
		if _, exists := allTSLs[p.TSLLocation]; exists {
			continue
		}

		// Fetch the referenced TSL
		url := p.TSLLocation
		refTsl, err := FetchTSLWithOptions(url, options)

		// If the URL ends with .pdf and fetch failed, try .xml instead
		if err != nil && strings.HasSuffix(strings.ToLower(url), ".pdf") {
			xmlURL := url[:len(url)-4] + ".xml" // Replace .pdf with .xml
			log.Debugf("g119612: Failed to fetch TSL from PDF URL %s, trying XML URL %s", url, xmlURL)

			refTsl, err = FetchTSLWithOptions(xmlURL, options)
			if err == nil {
				// Update the URL to the working one for future reference
				url = xmlURL
				log.Infof("g119612: Successfully fetched XML version instead of PDF: %s", xmlURL)
			}
		}

		if err != nil {
			log.Warnf("g119612: Failed to fetch referenced TSL %s: %v", p.TSLLocation, err)
			continue
		}

		// Add to the referenced list and the map
		tsl.AddReferencedTSL(refTsl)
		allTSLs[url] = refTsl // Use potentially updated URL

		// Recursively process this TSL's references
		if err := refTsl.dereferencePointersTSLsRecursive(options, allTSLs, currentDepth+1); err != nil {
			// Log but continue with other references
			log.Warnf("g119612: Error dereferencing TSL %s: %v", p.TSLLocation, err)
		}
	}

	return nil
}

// WithTrustServices walks a TSL, calling cb once for each TrustService found. The TrustServiceProvider is provided as a first
// argument to the callback
func (tsl *TSL) WithTrustServices(cb func(*TSPType, *TSPServiceType)) {
	if tsl.StatusList.TslTrustServiceProviderList == nil {
		return
	}
	for _, tsp := range tsl.StatusList.TslTrustServiceProviderList.TslTrustServiceProvider {
		if tsp != nil && tsp.TslTSPServices != nil {
			for _, svc := range tsp.TslTSPServices.TslTSPService {
				cb(tsp, svc)
			}
		}
	}
}

// Generate a [crypto/xml.CertPool] object from the TSL.
func (tsl *TSL) ToCertPool(policy *TSPServicePolicy) *x509.CertPool {
	pool := x509.NewCertPool()
	tsl.WithTrustServices(func(tsp *TSPType, svc *TSPServiceType) {
		svc.WithCertificates(func(cert *x509.Certificate) {
			// Only add cert if policy is satisfied
			if tsp.Validate(svc, []*x509.Certificate{cert}, policy) == nil {
				pool.AddCert(cert)
			}
		})
	})
	return pool
}

// ToCertPoolWithReferences generates a [crypto/xml.CertPool] object from the TSL and all its referenced TSLs.
// This method processes this TSL and all TSLs found in the Referenced slice.
//
// Parameters:
//   - policy: The policy to apply when validating certificates
//
// Returns:
//   - *x509.CertPool: A certificate pool containing all valid certificates from this TSL
//     and all its referenced TSLs that satisfy the given policy
func (tsl *TSL) ToCertPoolWithReferences(policy *TSPServicePolicy) *x509.CertPool {
	pool := x509.NewCertPool()

	// Process the main TSL
	tsl.WithTrustServices(func(tsp *TSPType, svc *TSPServiceType) {
		svc.WithCertificates(func(cert *x509.Certificate) {
			// Only add cert if policy is satisfied
			if tsp.Validate(svc, []*x509.Certificate{cert}, policy) == nil {
				pool.AddCert(cert)
			}
		})
	})

	// Process all referenced TSLs
	for _, refTsl := range tsl.Referenced {
		if refTsl != nil {
			refTsl.WithTrustServices(func(tsp *TSPType, svc *TSPServiceType) {
				svc.WithCertificates(func(cert *x509.Certificate) {
					// Only add cert if policy is satisfied
					if tsp.Validate(svc, []*x509.Certificate{cert}, policy) == nil {
						pool.AddCert(cert)
					}
				})
			})
		}
	}

	return pool
}
