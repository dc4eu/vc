package ecdsa

import (
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/hmac"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"math/big"
	"regexp"
	"sort"
	"strings"
	"time"

	"vc/pkg/vc20/credential"

	"github.com/fxamacker/cbor/v2"
	"github.com/multiformats/go-multibase"
	"github.com/piprate/json-gold/ld"
)

const (
	CryptosuiteSd2023 = "ecdsa-sd-2023"
)

// SdSuite implements the ECDSA Selective Disclosure Cryptosuite v1.0
type SdSuite struct {
}

// NewSdSuite creates a new ECDSA SD cryptosuite
func NewSdSuite() *SdSuite {
	return &SdSuite{}
}

// SdSignOptions contains options for signing with selective disclosure
type SdSignOptions struct {
	VerificationMethod string
	ProofPurpose       string
	Created            time.Time
	Domain             string
	Challenge          string
	MandatoryPointers  []string // JSON pointers to mandatory fields
}

// BaseProofValue represents the decoded proof value for a base proof
// Encoded as a CBOR array
type BaseProofValue struct {
	BaseSignature     []byte   `cbor:"0,keyasint"`
	PublicKey         []byte   `cbor:"1,keyasint"`
	HmacKey           []byte   `cbor:"2,keyasint"`
	Signatures        [][]byte `cbor:"3,keyasint"`
	MandatoryPointers []string `cbor:"4,keyasint"`
}

// DerivedProofValue represents the decoded proof value for a derived proof
// Encoded as a CBOR array
type DerivedProofValue struct {
	BaseSignature    []byte            `cbor:"0,keyasint"`
	PublicKey        []byte            `cbor:"1,keyasint"`
	Signatures       [][]byte          `cbor:"2,keyasint"`
	LabelMap         map[string]string `cbor:"3,keyasint"`
	MandatoryIndexes []int             `cbor:"4,keyasint"`
}

// Helper to encode as CBOR array
func toCborArray(v interface{}) ([]byte, error) {
	// We can use the "toarray" tag if we define a struct, or just marshal a slice
	// But the struct fields have different types.
	// Let's use a struct with `cbor:",toarray"` tag.
	return cbor.Marshal(v)
}

// BaseProofValueArray is used for CBOR serialization as an array
type BaseProofValueArray struct {
	_                 struct{} `cbor:",toarray"`
	BaseSignature     []byte
	PublicKey         []byte
	HmacKey           []byte
	Signatures        [][]byte
	MandatoryPointers []string
}

// DerivedProofValueArray is used for CBOR serialization as an array
type DerivedProofValueArray struct {
	_                struct{} `cbor:",toarray"`
	BaseSignature    []byte
	PublicKey        []byte
	Signatures       [][]byte
	LabelMap         map[string]string
	MandatoryIndexes []int
}

// Sign creates a Base Proof for the credential
func (s *SdSuite) Sign(cred *credential.RDFCredential, key *ecdsa.PrivateKey, opts *SdSignOptions) (*credential.RDFCredential, error) {
	if cred == nil {
		return nil, fmt.Errorf("credential is nil")
	}
	if key == nil {
		return nil, fmt.Errorf("private key is nil")
	}
	if opts == nil {
		return nil, fmt.Errorf("sign options are nil")
	}

	// 1. Generate HMAC key
	hmacKey := make([]byte, 32)
	if _, err := rand.Read(hmacKey); err != nil {
		return nil, fmt.Errorf("failed to generate HMAC key: %w", err)
	}

	// 2. Transform document to N-Quads
	// We use the existing RDFCredential functionality
	// But we need to be careful about the "without proof" part.
	credWithoutProof, err := cred.GetCredentialWithoutProof()
	if err != nil {
		return nil, fmt.Errorf("failed to get credential without proof: %w", err)
	}

	// Get N-Quads (normalized)
	// Note: The spec says we should skolemize *before* normalization if we want to preserve blank node relationships?
	// Actually, spec says: "Transform to RDF... Replace blank node identifiers... Canonicalize".
	// RDFCredential.GetCanonicalForm() does Normalize() which produces canonical N-Quads with _:c14n0 labels.
	// We need to intercept the N-Quads *before* they are canonicalized to stable IDs?
	// Or do we take the canonical IDs and HMAC them?
	// Spec: "Replace all blank node identifiers in the N-Quads with identifiers generated by HMAC..."
	// If we use GetCanonicalForm, we get _:c14n0, _:c14n1...
	// If we HMAC those, it's deterministic based on the content.
	// This seems correct for "Skolemization" in this context - we want stable IDs that are blinded.

	nquadsStr, err := credWithoutProof.GetCanonicalForm()
	if err != nil {
		return nil, fmt.Errorf("failed to get canonical form: %w", err)
	}

	// Parse N-Quads
	quads := parseNQuads(nquadsStr)

	// 3. Skolemize (HMAC blank nodes)
	// We need to replace _:c14n... with _:HMAC(...)
	// Since we used GetCanonicalForm, the blank nodes are already canonicalized.
	// We just need to map them.

	skolemizedQuads := make([]string, len(quads))
	for i, quad := range quads {
		skolemizedQuads[i] = skolemizeQuad(quad, hmacKey)
	}

	// 4. Separate Mandatory and Non-Mandatory
	// For now, assume all are non-mandatory (selective)
	// TODO: Implement mandatory pointer logic
	mandatoryQuads := []string{}
	nonMandatoryQuads := skolemizedQuads

	// 5. Group Non-Mandatory Quads
	// Map: GroupID -> []Quad
	groups := make(map[string][]string)

	for _, quad := range nonMandatoryQuads {
		// Parse quad to find subject and object
		s, p, o, g := parseQuadComponents(quad)
		_ = p
		_ = g

		// If subject is blank node
		if strings.HasPrefix(s, "_:") {
			groups[s] = append(groups[s], quad)
		}
		// If object is blank node
		if strings.HasPrefix(o, "_:") {
			groups[o] = append(groups[o], quad)
		}
		// If neither
		if !strings.HasPrefix(s, "_:") && !strings.HasPrefix(o, "_:") {
			groups[s] = append(groups[s], quad)
		}
	}

	// 6. Sign Groups
	// Generate ephemeral key
	ephemeralKey, err := ecdsa.GenerateKey(key.Curve, rand.Reader)
	if err != nil {
		return nil, fmt.Errorf("failed to generate ephemeral key: %w", err)
	}

	// We need to order the groups to ensure deterministic signature order?
	// The spec says "signatures" is a list.
	// We need to map signatures to groups.
	// The Derived Proof will contain a subset of signatures.
	// The holder needs to know which signature corresponds to which quad/group.
	// The spec says: "The signatures array contains the signatures for the non-mandatory N-Quads."
	// "The order of signatures MUST correspond to the order of the groups."
	// But what is the order of groups?
	// "Sort the keys of the group map..."

	groupKeys := make([]string, 0, len(groups))
	for k := range groups {
		groupKeys = append(groupKeys, k)
	}
	sort.Strings(groupKeys)

	var signatures [][]byte

	for _, k := range groupKeys {
		groupQuads := groups[k]
		// Canonicalize group (sort quads)
		sort.Strings(groupQuads)
		// Join with newlines
		groupStr := strings.Join(groupQuads, "\n") + "\n"

		// Hash
		hash := sha256.Sum256([]byte(groupStr))

		// Sign with ephemeral key
		r, s, err := ecdsa.Sign(rand.Reader, ephemeralKey, hash[:])
		if err != nil {
			return nil, fmt.Errorf("failed to sign group %s: %w", k, err)
		}

		// Serialize signature
		sigBytes := serializeSignature(r, s, ephemeralKey.Curve.Params().BitSize)
		signatures = append(signatures, sigBytes)
	}

	// 7. Create Base Proof
	// Proof Config
	created := opts.Created
	if created.IsZero() {
		created = time.Now().UTC()
	}

	proofConfig := map[string]interface{}{
		"@context":           "https://www.w3.org/ns/credentials/v2",
		"type":               ProofType,
		"cryptosuite":        CryptosuiteSd2023,
		"verificationMethod": opts.VerificationMethod,
		"proofPurpose":       opts.ProofPurpose,
		"created":            created.Format(time.RFC3339),
	}
	if opts.Domain != "" {
		proofConfig["domain"] = opts.Domain
	}
	if opts.Challenge != "" {
		proofConfig["challenge"] = opts.Challenge
	}

	// Canonicalize Proof Config
	proofConfigBytes, err := json.Marshal(proofConfig)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal proof config: %w", err)
	}
	ldOpts := ld.NewJsonLdOptions("")
	ldOpts.Algorithm = ld.AlgorithmURDNA2015
	proofCred, err := credential.NewRDFCredentialFromJSON(proofConfigBytes, ldOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to create proof config credential: %w", err)
	}
	proofCanonical, err := proofCred.GetCanonicalForm()
	if err != nil {
		return nil, fmt.Errorf("failed to canonicalize proof config: %w", err)
	}
	proofHash := sha256.Sum256([]byte(proofCanonical))

	// Mandatory Hash
	// If no mandatory quads, hash of empty string? Or hash of nothing?
	// Spec: "Hash the canonicalized mandatory N-Quads."
	var mandatoryHash []byte
	if len(mandatoryQuads) > 0 {
		sort.Strings(mandatoryQuads)
		mandatoryStr := strings.Join(mandatoryQuads, "\n") + "\n"
		h := sha256.Sum256([]byte(mandatoryStr))
		mandatoryHash = h[:]
	} else {
		// Hash of empty string?
		h := sha256.Sum256([]byte(""))
		mandatoryHash = h[:]
	}

	// Ephemeral Public Key
	ephemeralPubBytes := ellipticMarshal(ephemeralKey.PublicKey)

	// Combine for Base Signature
	// hash(proofHash + ephemeralPub + mandatoryHash)
	combined := append(proofHash[:], ephemeralPubBytes...)
	combined = append(combined, mandatoryHash...)

	// Sign with Issuer Key
	sigR, sigS, err := ecdsa.Sign(rand.Reader, key, combined)
	if err != nil {
		return nil, fmt.Errorf("failed to sign base proof: %w", err)
	}
	baseSignature := serializeSignature(sigR, sigS, key.Curve.Params().BitSize)

	// Construct BaseProofValue
	bpv := BaseProofValueArray{
		BaseSignature:     baseSignature,
		PublicKey:         ephemeralPubBytes,
		HmacKey:           hmacKey,
		Signatures:        signatures,
		MandatoryPointers: opts.MandatoryPointers,
	}

	// Encode CBOR
	cborBytes, err := cbor.Marshal(bpv)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal CBOR: %w", err)
	}

	// Encode Multibase (base64url header 'u')
	// Spec says "multibase-encoded base proof value".
	// Usually base64url is 'u'.
	proofValue, err := multibase.Encode(multibase.Base64url, cborBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to encode multibase: %w", err)
	}

	// Add to credential
	// ... (Same as before)
	var credMap map[string]interface{}
	originalJSON := cred.GetOriginalJSON()
	if originalJSON != "" {
		if err := json.Unmarshal([]byte(originalJSON), &credMap); err != nil {
			return nil, fmt.Errorf("failed to unmarshal original credential: %w", err)
		}
	} else {
		jsonBytes, err := cred.ToJSON()
		if err != nil {
			return nil, fmt.Errorf("failed to convert credential to JSON: %w", err)
		}
		if err := json.Unmarshal(jsonBytes, &credMap); err != nil {
			return nil, fmt.Errorf("failed to unmarshal converted credential: %w", err)
		}
	}

	proofConfig["proofValue"] = proofValue

	if existingProof, ok := credMap["proof"]; ok {
		if proofs, ok := existingProof.([]interface{}); ok {
			credMap["proof"] = append(proofs, proofConfig)
		} else {
			credMap["proof"] = []interface{}{existingProof, proofConfig}
		}
	} else {
		credMap["proof"] = proofConfig
	}

	newCredBytes, err := json.Marshal(credMap)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal new credential: %w", err)
	}

	return credential.NewRDFCredentialFromJSON(newCredBytes, ldOpts)
}

// Verify verifies a credential using ecdsa-sd-2023
func (s *SdSuite) Verify(cred *credential.RDFCredential, key *ecdsa.PublicKey) error {
	if cred == nil {
		return fmt.Errorf("credential is nil")
	}
	if key == nil {
		return fmt.Errorf("public key is nil")
	}

	// 1. Extract proof
	proofCred, err := cred.GetProofObject()
	if err != nil {
		return fmt.Errorf("failed to get proof object: %w", err)
	}

	proofJSONBytes, err := proofCred.ToJSON()
	if err != nil {
		return fmt.Errorf("failed to convert proof to JSON: %w", err)
	}

	var proofJSON interface{}
	if err := json.Unmarshal(proofJSONBytes, &proofJSON); err != nil {
		return fmt.Errorf("failed to unmarshal proof JSON: %w", err)
	}

	// Compact proof
	proc := ld.NewJsonLdProcessor()
	compactOpts := ld.NewJsonLdOptions("")

	var context interface{}
	if ctx, err := cred.GetContext(); err == nil {
		var ctxList []interface{}
		if list, ok := ctx.([]interface{}); ok {
			ctxList = append(ctxList, list...)
		} else {
			ctxList = append(ctxList, ctx)
		}

		// Add V2 context if not present
		hasV2 := false
		for _, c := range ctxList {
			if s, ok := c.(string); ok && s == "https://www.w3.org/ns/credentials/v2" {
				hasV2 = true
				break
			}
		}
		if !hasV2 {
			ctxList = append(ctxList, "https://www.w3.org/ns/credentials/v2")
		}

		context = map[string]interface{}{
			"@context": ctxList,
		}
	} else {
		context = map[string]interface{}{
			"@context": "https://www.w3.org/ns/credentials/v2",
		}
	}

	compactedProof, err := proc.Compact(proofJSON, context, compactOpts)
	if err != nil {
		return fmt.Errorf("failed to compact proof JSON: %w", err)
	}

	proofMap := sdFindProofNode(compactedProof)
	if proofMap == nil {
		return fmt.Errorf("proof node not found")
	}

	proofValueStr, ok := proofMap["proofValue"].(string)
	if !ok {
		// Try full URIs
		proofValueStr, ok = proofMap["https://w3id.org/security#proofValue"].(string)
		if !ok {
			proofValueStr, ok = proofMap["https://www.w3.org/ns/credentials#proofValue"].(string)
		}
	}
	if !ok {
		return fmt.Errorf("proofValue not found")
	}

	// Decode proofValue
	_, proofValueBytes, err := multibase.Decode(proofValueStr)
	if err != nil {
		return fmt.Errorf("failed to decode proofValue: %w", err)
	}

	// Try to decode as BaseProofValue
	var baseProof BaseProofValueArray
	isBaseProof := true
	if err := cbor.Unmarshal(proofValueBytes, &baseProof); err != nil {
		// Try DerivedProofValue
		isBaseProof = false
	} else {
		// Check if it has HmacKey (Base Proof specific)
		if len(baseProof.HmacKey) == 0 {
			isBaseProof = false
		}
	}

	if isBaseProof {
		return s.verifyBaseProof(cred, key, &baseProof, proofMap)
	}

	var derivedProof DerivedProofValueArray
	if err := cbor.Unmarshal(proofValueBytes, &derivedProof); err != nil {
		return fmt.Errorf("failed to unmarshal proof value as Base or Derived proof: %w", err)
	}

	return s.verifyDerivedProof(cred, key, &derivedProof, proofMap)
}

func (s *SdSuite) verifyBaseProof(cred *credential.RDFCredential, key *ecdsa.PublicKey, proof *BaseProofValueArray, proofMap map[string]interface{}) error {
	// 1. Verify Base Signature
	// Reconstruct the signed data: hash(proofHash + ephemeralPub + mandatoryHash)

	// Canonicalize Proof Config (without proofValue)
	delete(proofMap, "proofValue")
	if _, ok := proofMap["@context"]; !ok {
		proofMap["@context"] = "https://www.w3.org/ns/credentials/v2"
	}
	proofConfigBytes, err := json.Marshal(proofMap)
	if err != nil {
		return fmt.Errorf("failed to marshal proof config: %w", err)
	}
	ldOpts := ld.NewJsonLdOptions("")
	ldOpts.Algorithm = ld.AlgorithmURDNA2015
	proofCred, err := credential.NewRDFCredentialFromJSON(proofConfigBytes, ldOpts)
	if err != nil {
		return fmt.Errorf("failed to create proof config credential: %w", err)
	}
	proofCanonical, err := proofCred.GetCanonicalForm()
	if err != nil {
		return fmt.Errorf("failed to canonicalize proof config: %w", err)
	}
	proofHash := sha256.Sum256([]byte(proofCanonical))

	// Mandatory Hash
	// For Base Proof, we have the full document, so we can re-calculate mandatory quads.
	// But we need the mandatory pointers.
	// They are in the proof value.
	// TODO: Implement mandatory pointer selection.
	// For now, assume empty.
	mandatoryHash := sha256.Sum256([]byte(""))
	if len(proof.MandatoryPointers) > 0 {
		// If we had logic to select mandatory quads, we would use it here.
		// Since we don't, and we assumed empty in Sign, this matches.
		// If Sign used pointers, we would fail here.
	}

	// Ephemeral Public Key
	ephemeralPub := proof.PublicKey

	combined := append(proofHash[:], ephemeralPub...)
	combined = append(combined, mandatoryHash[:]...)

	// Verify Base Signature
	if !verifySignature(key, combined, proof.BaseSignature) {
		return fmt.Errorf("base signature verification failed")
	}

	// 2. Verify Individual Signatures
	// We need to reconstruct groups and verify them against proof.Signatures
	// Transform document to N-Quads
	credWithoutProof, err := cred.GetCredentialWithoutProof()
	if err != nil {
		return fmt.Errorf("failed to get credential without proof: %w", err)
	}
	nquadsStr, err := credWithoutProof.GetCanonicalForm()
	if err != nil {
		return fmt.Errorf("failed to get canonical form: %w", err)
	}
	quads := parseNQuads(nquadsStr)

	// Skolemize
	skolemizedQuads := make([]string, len(quads))
	for i, quad := range quads {
		skolemizedQuads[i] = skolemizeQuad(quad, proof.HmacKey)
	}

	// Group (assuming all non-mandatory)
	groups := make(map[string][]string)
	for _, quad := range skolemizedQuads {
		s, _, o, _ := parseQuadComponents(quad)
		if strings.HasPrefix(s, "_:") {
			groups[s] = append(groups[s], quad)
		}
		if strings.HasPrefix(o, "_:") {
			groups[o] = append(groups[o], quad)
		}
		if !strings.HasPrefix(s, "_:") && !strings.HasPrefix(o, "_:") {
			groups[s] = append(groups[s], quad)
		}
	}

	groupKeys := make([]string, 0, len(groups))
	for k := range groups {
		groupKeys = append(groupKeys, k)
	}
	sort.Strings(groupKeys)

	if len(groupKeys) != len(proof.Signatures) {
		return fmt.Errorf("number of groups (%d) does not match number of signatures (%d)", len(groupKeys), len(proof.Signatures))
	}

	// Parse Ephemeral Key
	x, y := elliptic.Unmarshal(key.Curve, proof.PublicKey)
	if x == nil {
		return fmt.Errorf("invalid ephemeral public key")
	}
	ephemeralKey := &ecdsa.PublicKey{Curve: key.Curve, X: x, Y: y}

	for i, k := range groupKeys {
		groupQuads := groups[k]
		sort.Strings(groupQuads)
		groupStr := strings.Join(groupQuads, "\n") + "\n"
		hash := sha256.Sum256([]byte(groupStr))

		if !verifySignature(ephemeralKey, hash[:], proof.Signatures[i]) {
			return fmt.Errorf("signature verification failed for group %s", k)
		}
	}

	return nil
}

func (s *SdSuite) verifyDerivedProof(cred *credential.RDFCredential, key *ecdsa.PublicKey, proof *DerivedProofValueArray, proofMap map[string]interface{}) error {
	// 1. Verify Base Signature
	// Reconstruct signed data.
	// We need proofHash, ephemeralPub, mandatoryHash.

	// Proof Hash
	delete(proofMap, "proofValue")
	delete(proofMap, "https://w3id.org/security#proofValue")
	delete(proofMap, "https://www.w3.org/ns/credentials#proofValue")
	// Remove id to match Sign configuration
	delete(proofMap, "id")
	delete(proofMap, "@id")

	if _, ok := proofMap["@context"]; !ok {
		proofMap["@context"] = "https://www.w3.org/ns/credentials/v2"
	}
	proofConfigBytes, err := json.Marshal(proofMap)
	if err != nil {
		return fmt.Errorf("failed to marshal proof config: %w", err)
	}
	ldOpts := ld.NewJsonLdOptions("")
	ldOpts.Algorithm = ld.AlgorithmURDNA2015
	proofCred, err := credential.NewRDFCredentialFromJSON(proofConfigBytes, ldOpts)
	if err != nil {
		return fmt.Errorf("failed to create proof config credential: %w", err)
	}
	proofCanonical, err := proofCred.GetCanonicalForm()
	if err != nil {
		return fmt.Errorf("failed to canonicalize proof config: %w", err)
	}
	proofHash := sha256.Sum256([]byte(proofCanonical))

	// Mandatory Hash
	// We need to reconstruct mandatory quads from the derived document.
	// The derived document contains mandatory quads AND revealed non-mandatory quads.
	// How do we distinguish?
	// The proof has `MandatoryIndexes`? No, `MandatoryIndexes` in DerivedProofValue is for something else?
	// Spec: "mandatoryIndexes: A list of indices into the mandatory N-Quads list."
	// Wait, if we don't have the full list of mandatory quads, how do we verify the hash?
	// Ah, the Derived Proof does NOT contain the mandatory hash?
	// The Base Signature signs the mandatory hash.
	// So the Verifier must be able to reconstruct the mandatory hash.
	// This implies the Verifier must have ALL mandatory quads.
	// Yes, mandatory quads are always revealed.
	// So we extract mandatory quads from the derived document.
	// But we also have revealed non-mandatory quads.
	// We need to know which are which.
	// The `MandatoryIndexes` might help?
	// Or maybe we just assume all quads in the derived document are either mandatory or revealed non-mandatory.
	// But to verify the Base Signature, we need the hash of ONLY the mandatory quads.
	// If we can't separate them, we can't verify.

	// Spec Section 3.6 Verification:
	// "Transform the derived document to an RDF dataset."
	// "Filter the N-Quads to find those that are mandatory."
	// "This filtering is done by matching the N-Quads against the mandatory pointers."
	// BUT the mandatory pointers are in the Base Proof, which we don't have!
	// The Derived Proof doesn't have mandatory pointers.
	// Wait, does the Derived Proof contain the mandatory pointers?
	// The `BaseProofValue` has them. The `DerivedProofValue` does NOT.
	// So how does the verifier know what is mandatory?
	// Maybe the verifier is supposed to know the schema?
	// Or maybe `MandatoryIndexes` tells us?
	// Spec says: "mandatoryIndexes: A list of integers... indices into the list of mandatory N-Quads."
	// This seems to imply we have a list.

	// Let's check the spec again about `DerivedProofValue`.
	// It has `mandatoryIndexes`.
	// Maybe I missed something.

	// Actually, if `MandatoryPointers` was empty (as we implemented), then `mandatoryHash` is hash of empty string.
	// So we can verify if we assume no mandatory quads.
	// If there ARE mandatory quads, we need to know which ones they are.

	// For now, assume empty mandatory quads.
	mandatoryHash := sha256.Sum256([]byte(""))

	ephemeralPub := proof.PublicKey

	combined := append(proofHash[:], ephemeralPub...)
	combined = append(combined, mandatoryHash[:]...)

	if !verifySignature(key, combined, proof.BaseSignature) {
		return fmt.Errorf("base signature verification failed")
	}

	// 2. Verify Revealed Quads
	// We need to apply the LabelMap BEFORE canonicalization to ensure stable IDs.
	// We replace mapped blank nodes with URNs in the JSON-LD.

	// Instead of GetCredentialWithoutProof, we use the original JSON and remove proof manually
	// to preserve blank node IDs.
	var credJSON interface{}
	originalJSON := cred.GetOriginalJSON()
	if originalJSON != "" {
		if err := json.Unmarshal([]byte(originalJSON), &credJSON); err != nil {
			return fmt.Errorf("failed to unmarshal original JSON: %w", err)
		}
	} else {
		// Fallback
		jsonBytes, err := cred.ToJSON()
		if err != nil {
			return fmt.Errorf("failed to get JSON: %w", err)
		}
		if err := json.Unmarshal(jsonBytes, &credJSON); err != nil {
			return fmt.Errorf("failed to unmarshal JSON: %w", err)
		}
	}

	// Remove proof
	removeProof(credJSON)

	// Replace labels with URNs
	replaceLabelsWithURNs(credJSON, proof.LabelMap)

	// Create new credential from modified map
	modBytes, err := json.Marshal(credJSON)
	if err != nil {
		return fmt.Errorf("failed to marshal modified credential: %w", err)
	}
	ldOpts = ld.NewJsonLdOptions("")
	ldOpts.Algorithm = ld.AlgorithmURDNA2015
	modCred, err := credential.NewRDFCredentialFromJSON(modBytes, ldOpts)
	if err != nil {
		return fmt.Errorf("failed to create modified credential: %w", err)
	}

	// Get Canonical Form (this will preserve URNs)
	nquadsStr, err := modCred.GetCanonicalForm()
	if err != nil {
		return fmt.Errorf("failed to get canonical form: %w", err)
	}

	// Replace URNs with blank nodes in N-Quads
	// <urn:bn:HMAC> -> _:HMAC
	nquadsStr = replaceURNsInNQuads(nquadsStr)

	mappedQuads := parseNQuads(nquadsStr)

	// Group
	groups := make(map[string][]string)
	for _, quad := range mappedQuads {
		s, _, o, _ := parseQuadComponents(quad)
		if strings.HasPrefix(s, "_:") {
			groups[s] = append(groups[s], quad)
		}
		if strings.HasPrefix(o, "_:") {
			groups[o] = append(groups[o], quad)
		}
		if !strings.HasPrefix(s, "_:") && !strings.HasPrefix(o, "_:") {
			groups[s] = append(groups[s], quad)
		}
	}

	groupKeys := make([]string, 0, len(groups))
	for k := range groups {
		groupKeys = append(groupKeys, k)
	}
	sort.Strings(groupKeys)

	// Verify signatures for groups
	// We have `proof.Signatures`.
	// But this list might be a subset of the original signatures?
	// Or does it contain ONLY the signatures for the revealed groups?
	// Spec: "The signatures array contains the signatures for the non-mandatory N-Quads that are revealed."
	// "The order of signatures MUST correspond to the order of the groups."

	if len(groupKeys) != len(proof.Signatures) {
		return fmt.Errorf("number of groups (%d) does not match number of signatures (%d)", len(groupKeys), len(proof.Signatures))
	}

	// Parse Ephemeral Key
	x, y := elliptic.Unmarshal(key.Curve, proof.PublicKey)
	if x == nil {
		return fmt.Errorf("invalid ephemeral public key")
	}
	ephemeralKey := &ecdsa.PublicKey{Curve: key.Curve, X: x, Y: y}

	for i, k := range groupKeys {
		groupQuads := groups[k]
		sort.Strings(groupQuads)
		groupStr := strings.Join(groupQuads, "\n") + "\n"
		hash := sha256.Sum256([]byte(groupStr))

		if !verifySignature(ephemeralKey, hash[:], proof.Signatures[i]) {
			return fmt.Errorf("signature verification failed for group %s", k)
		}
	}

	return nil
}

// Derive creates a Derived Proof from a Base Proof
func (s *SdSuite) Derive(cred *credential.RDFCredential, revealIndices []int, nonce string) (*credential.RDFCredential, error) {
	if cred == nil {
		return nil, fmt.Errorf("credential is nil")
	}

	// 1. Extract Base Proof
	proofCred, err := cred.GetProofObject()
	if err != nil {
		return nil, fmt.Errorf("failed to get proof object: %w", err)
	}
	proofJSONBytes, err := proofCred.ToJSON()
	if err != nil {
		return nil, fmt.Errorf("failed to convert proof to JSON: %w", err)
	}
	var proofJSON interface{}
	if err := json.Unmarshal(proofJSONBytes, &proofJSON); err != nil {
		return nil, fmt.Errorf("failed to unmarshal proof JSON: %w", err)
	}

	proc := ld.NewJsonLdProcessor()
	compactOpts := ld.NewJsonLdOptions("")
	context := map[string]interface{}{
		"@context": "https://www.w3.org/ns/credentials/v2",
	}
	compactedProof, err := proc.Compact(proofJSON, context, compactOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to compact proof JSON: %w", err)
	}
	proofMap := sdFindProofNode(compactedProof)
	if proofMap == nil {
		return nil, fmt.Errorf("proof node not found")
	}
	proofValueStr, ok := proofMap["proofValue"].(string)
	if !ok {
		return nil, fmt.Errorf("proofValue not found")
	}

	_, proofValueBytes, err := multibase.Decode(proofValueStr)
	if err != nil {
		return nil, fmt.Errorf("failed to decode proofValue: %w", err)
	}

	var baseProof BaseProofValueArray
	if err := cbor.Unmarshal(proofValueBytes, &baseProof); err != nil {
		return nil, fmt.Errorf("failed to unmarshal base proof: %w", err)
	}

	// 2. Get Original Quads & Skolemize
	credWithoutProof, err := cred.GetCredentialWithoutProof()
	if err != nil {
		return nil, fmt.Errorf("failed to get credential without proof: %w", err)
	}
	nquadsStr, err := credWithoutProof.GetCanonicalForm()
	if err != nil {
		return nil, fmt.Errorf("failed to get canonical form: %w", err)
	}
	quads := parseNQuads(nquadsStr)

	skolemizedQuads := make([]string, len(quads))
	for i, quad := range quads {
		skolemizedQuads[i] = skolemizeQuad(quad, baseProof.HmacKey)
	}

	// 3. Select Revealed Quads
	// We assume revealIndices refers to the sorted list of non-mandatory quads?
	// Or indices into the original list?
	// The user gives indices. Let's assume they are indices into `skolemizedQuads`.
	// But wait, `skolemizedQuads` order depends on canonicalization.
	// The user needs to know the order.
	// This API is low-level.

	// Filter quads
	// Also need to keep track of which groups are revealed to filter signatures.

	// We need to reconstruct the groups to know which signature corresponds to which quad.
	// Grouping
	// 1. Identify which groups the selected quads belong to.
	// 2. Collect ALL quads from those groups.
	// 3. These are the `revealedQuads`.

	// But wait, if I have to reveal the whole group, and the group is "all attributes of the DID", then I reveal everything.
	// This implies `ecdsa-sd-2023` requires using blank nodes for selective disclosure of attributes?
	// Yes, likely. The credential structure must use blank nodes (e.g. `credentialSubject` is a blank node, or attributes are broken out).

	// Re-implement grouping to map GroupID -> Quads
	groups := make(map[string][]string)
	for _, quad := range skolemizedQuads {
		s, _, o, _ := parseQuadComponents(quad)
		if strings.HasPrefix(s, "_:") {
			groups[s] = append(groups[s], quad)
		}
		if strings.HasPrefix(o, "_:") {
			groups[o] = append(groups[o], quad)
		}
		if !strings.HasPrefix(s, "_:") && !strings.HasPrefix(o, "_:") {
			groups[s] = append(groups[s], quad)
		}
	}

	// Determine which groups are targeted by revealIndices
	targetGroups := make(map[string]bool)
	for _, idx := range revealIndices {
		if idx < 0 || idx >= len(skolemizedQuads) {
			continue
		}
		quad := skolemizedQuads[idx]
		s, _, o, _ := parseQuadComponents(quad)
		if strings.HasPrefix(s, "_:") {
			targetGroups[s] = true
		}
		if strings.HasPrefix(o, "_:") {
			targetGroups[o] = true
		}
		if !strings.HasPrefix(s, "_:") && !strings.HasPrefix(o, "_:") {
			targetGroups[s] = true
		}
	}

	// Collect all quads from target groups
	// And collect signatures

	// We need the sorted group keys from the Base Proof generation to match signatures
	allGroupKeys := make([]string, 0, len(groups))
	for k := range groups {
		allGroupKeys = append(allGroupKeys, k)
	}
	sort.Strings(allGroupKeys)

	var derivedSignatures [][]byte
	var finalRevealedQuads []string

	// We need to know which signature corresponds to which group key.
	// The Base Proof has `Signatures` array corresponding to `allGroupKeys`.

	if len(baseProof.Signatures) != len(allGroupKeys) {
		return nil, fmt.Errorf("base proof signatures count (%d) does not match groups count (%d)", len(baseProof.Signatures), len(allGroupKeys))
	}

	// Label Map: NewID -> HMAC_ID
	labelMap := make(map[string]string)
	// We need to generate new IDs for the revealed blank nodes.
	// Map: HMAC_ID -> NewID
	hmacToNew := make(map[string]string)

	for i, k := range allGroupKeys {
		if targetGroups[k] {
			// This group is revealed
			derivedSignatures = append(derivedSignatures, baseProof.Signatures[i])

			// Add quads
			// We need to deduplicate quads if they are in multiple revealed groups?
			// A quad is a string.
			for _, q := range groups[k] {
				finalRevealedQuads = append(finalRevealedQuads, q)
			}

			// Handle Label Map
			// If k is a blank node (HMAC'd), we need to assign a new ID.
			if strings.HasPrefix(k, "_:") {
				hmacID := k[2:] // remove _:
				if _, exists := hmacToNew[hmacID]; !exists {
					// Generate new ID
					// Use simple counter or random?
					// Random is better.
					newID := fmt.Sprintf("b%d", len(hmacToNew)) // Simple for now
					hmacToNew[hmacID] = newID
					labelMap[newID] = hmacID
				}
			}
		}
	}

	// Deduplicate finalRevealedQuads
	uniqueQuads := make(map[string]bool)
	var dedupedQuads []string
	for _, q := range finalRevealedQuads {
		if !uniqueQuads[q] {
			uniqueQuads[q] = true
			dedupedQuads = append(dedupedQuads, q)
		}
	}

	// 4. Create Derived Document
	// We have dedupedQuads with HMAC IDs.
	// We need to replace HMAC IDs with New IDs.
	// We use URNs temporarily to prevent JSON-LD processor from renaming blank nodes during Frame.

	derivedQuads := make([]string, len(dedupedQuads))
	for i, quad := range dedupedQuads {
		// Replace all HMAC IDs with New IDs
		// We can use regex again
		re := regexp.MustCompile(`_:[a-zA-Z0-9\-_]+`)
		derivedQuads[i] = re.ReplaceAllStringFunc(quad, func(match string) string {
			hmacID := match[2:]
			var newID string
			if id, ok := hmacToNew[hmacID]; ok {
				newID = id
			} else {
				// Assign new ID if missing
				newID = fmt.Sprintf("b%d", len(hmacToNew))
				hmacToNew[hmacID] = newID
				labelMap[newID] = hmacID
			}
			// Return URN
			return fmt.Sprintf("<urn:bn:%s>", newID)
		})
	}

	// Convert derivedQuads to JSON-LD
	// Use json-gold FromRDF
	// Parse quads back to RDF triples
	// This is painful without a parser.
	// But we can construct a simple N-Quads string and parse it with json-gold?
	// json-gold has `ParseNQuads`.

	derivedNQuadsStr := strings.Join(derivedQuads, "\n")
	// fmt.Printf("DEBUG: Derived N-Quads:\n%s\n", derivedNQuadsStr)

	// FromRDF
	fromRdfOpts := ld.NewJsonLdOptions("")
	fromRdfOpts.Format = "application/n-quads"
	derivedDoc, err := proc.FromRDF(derivedNQuadsStr, fromRdfOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to convert to JSON-LD: %w", err)
	}

	// 5. Create Derived Proof
	derivedProofValue := DerivedProofValueArray{
		BaseSignature:    baseProof.BaseSignature,
		PublicKey:        baseProof.PublicKey,
		Signatures:       derivedSignatures,
		LabelMap:         labelMap,
		MandatoryIndexes: []int{}, // Empty for now
	}

	cborBytes, err := cbor.Marshal(derivedProofValue)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal derived proof: %w", err)
	}

	proofValue, err := multibase.Encode(multibase.Base64url, cborBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to encode proof value: %w", err)
	}

	// Construct Proof Config
	// Copy from original proof but replace proofValue
	newProofConfig := make(map[string]interface{})
	for k, v := range proofMap {
		newProofConfig[k] = v
	}
	newProofConfig["proofValue"] = proofValue

	// Get context from original credential
	originalContext, err := cred.GetContext()
	if err != nil {
		// Fallback if not available
		originalContext = "https://www.w3.org/ns/credentials/v2"
	}

	// Construct new context ensuring V2 is present
	var ctxList []interface{}
	if list, ok := originalContext.([]interface{}); ok {
		ctxList = append(ctxList, list...)
	} else {
		ctxList = append(ctxList, originalContext)
	}

	// Add V2 context if not present
	hasV2 := false
	for _, c := range ctxList {
		if s, ok := c.(string); ok && s == "https://www.w3.org/ns/credentials/v2" {
			hasV2 = true
			break
		}
	}
	if !hasV2 {
		ctxList = append(ctxList, "https://www.w3.org/ns/credentials/v2")
	}

	newContext := ctxList

	// Compact the derived document
	compactedDerived, err := proc.Compact(derivedDoc, map[string]interface{}{"@context": newContext}, compactOpts)
	if err != nil {
		return nil, fmt.Errorf("failed to compact derived credential: %w", err)
	}

	m := compactedDerived

	// Replace URNs back to blank nodes
	replaceURNs(m)

	// Force context to be the list we want, to avoid Framing merging it into a single object
	// which seems to cause issues with term resolution in ToRDF
	m["@context"] = newContext

	// Add proof to compacted credential
	if existingProof, ok := m["proof"]; ok {
		if proofs, ok := existingProof.([]interface{}); ok {
			m["proof"] = append(proofs, newProofConfig)
		} else {
			m["proof"] = []interface{}{existingProof, newProofConfig}
		}
	} else {
		m["proof"] = newProofConfig
	}

	derivedBytes, err := json.Marshal(m)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal derived credential: %w", err)
	}

	derivedCred, err := credential.NewRDFCredentialFromJSON(derivedBytes, ld.NewJsonLdOptions(""))
	if err != nil {
		return nil, err
	}

	return derivedCred, nil
}

// Helper functions

func parseNQuads(nquads string) []string {
	if nquads == "" {
		return []string{}
	}
	lines := strings.Split(nquads, "\n")
	var result []string
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			result = append(result, line)
		}
	}
	return result
}

func parseQuadComponents(quad string) (string, string, string, string) {
	// Very basic N-Quad parser
	// Assumes canonical format (spaces separate components)
	// Subject Predicate Object Graph .
	// Note: Object can be a string with spaces.
	// But in canonical form, strings are escaped.
	// We can use regex or simple splitting if we are careful.

	// Better: use a proper RDF parser if available, but we are working with strings here.
	// For grouping, we just need to identify blank nodes.

	parts := strings.SplitN(quad, " ", 3)
	if len(parts) < 3 {
		return "", "", "", ""
	}
	s := parts[0]
	p := parts[1]
	rest := parts[2]

	// Object is tricky. It ends with " ." or " <graph> ."
	// But since we only care about blank nodes which are _:..., they don't contain spaces.
	// If object is a literal, it starts with ".

	var o string
	// If rest starts with ", parse until end of string
	// If rest starts with < or _:, parse until space

	if strings.HasPrefix(rest, "\"") {
		// Literal. Find the end of the literal.
		// This is hard without full parsing.
		// But we only need to check if it is a blank node.
		// Literals are NOT blank nodes.
		o = "LITERAL" // Placeholder
	} else {
		oParts := strings.SplitN(rest, " ", 2)
		o = oParts[0]
	}

	return s, p, o, ""
}

func skolemizeQuad(quad string, key []byte) string {
	// Replace all _:... with _:HMAC(...)
	// We need to find all occurrences of _:([a-zA-Z0-9]+)
	// and replace them.

	re := regexp.MustCompile(`_:[a-zA-Z0-9\-_]+`)
	return re.ReplaceAllStringFunc(quad, func(match string) string {
		// match is _:label
		label := match[2:]
		h := hmacSha256(key, []byte(label))
		// Encode h as base64url or hex? Spec says "multibase base58-btc" usually for IDs?
		// Spec: "The identifier is the base64url-encoded HMAC."
		encoded := base64.URLEncoding.EncodeToString(h)
		// Remove padding?
		encoded = strings.TrimRight(encoded, "=")
		return "_:" + encoded
	})
}

func hmacSha256(key, data []byte) []byte {
	mac := hmac.New(sha256.New, key)
	mac.Write(data)
	return mac.Sum(nil)
}

func serializeSignature(r, s *big.Int, bits int) []byte {
	keyBytes := (bits + 7) / 8
	rBytes := r.Bytes()
	sBytes := s.Bytes()

	signature := make([]byte, 2*keyBytes)
	copy(signature[keyBytes-len(rBytes):keyBytes], rBytes)
	copy(signature[2*keyBytes-len(sBytes):], sBytes)
	return signature
}

func ellipticMarshal(pub ecdsa.PublicKey) []byte {
	// Use standard uncompressed point serialization
	// 0x04 || x || y
	return elliptic.Marshal(pub.Curve, pub.X, pub.Y)
}

func verifySignature(key *ecdsa.PublicKey, hash, signature []byte) bool {
	keyBytes := (key.Curve.Params().BitSize + 7) / 8
	if len(signature) != 2*keyBytes {
		return false
	}
	r := new(big.Int).SetBytes(signature[:keyBytes])
	s := new(big.Int).SetBytes(signature[keyBytes:])
	return ecdsa.Verify(key, hash, r, s)
}

func applyLabelMap(quad string, labelMap map[string]string) string {
	// Replace _:label with _:mappedLabel
	re := regexp.MustCompile(`_:[a-zA-Z0-9\-_]+`)
	return re.ReplaceAllStringFunc(quad, func(match string) string {
		label := match[2:]
		if mapped, ok := labelMap[label]; ok {
			// The mapped label in the map is the HMAC'd label (without _:)
			// Wait, the map values are the HMAC'd labels?
			// Spec: "The label map maps the blank node identifiers in the derived proof to the HMAC identifiers..."
			// So key=derivedID, value=hmacID.
			// But hmacID in the map might be the full string or just the hex/base64?
			// In Sign, we created `_:base64(HMAC)`.
			// So the value in the map should be `base64(HMAC)`.
			// And we should return `_:` + mapped.
			return "_:" + mapped
		}
		// If not in map, keep as is? Or error?
		// If it's a blank node that wasn't mapped, it might be a new one?
		// But in derived proof, all blank nodes should be mapped if they were in the original.
		return match
	})
}

func sdHasType(m map[string]interface{}, expectedType string) bool {
	t, ok := m["type"]
	if !ok {
		t, ok = m["@type"]
	}
	if !ok {
		return false
	}

	if s, ok := t.(string); ok {
		return s == expectedType
	}
	if list, ok := t.([]interface{}); ok {
		for _, item := range list {
			if s, ok := item.(string); ok && s == expectedType {
				return true
			}
		}
	}
	return false
}

func sdFindProofNode(data interface{}) map[string]interface{} {
	if m, ok := data.(map[string]interface{}); ok {
		if sdHasType(m, ProofType) || sdHasType(m, "Proof") {
			return m
		}
		// Check all values
		for _, v := range m {
			if found := sdFindProofNode(v); found != nil {
				return found
			}
		}
	} else if list, ok := data.([]interface{}); ok {
		for _, item := range list {
			if found := sdFindProofNode(item); found != nil {
				return found
			}
		}
	}
	return nil
}

func replaceURNs(data interface{}) {
	if m, ok := data.(map[string]interface{}); ok {
		for k, v := range m {
			if s, ok := v.(string); ok {
				if strings.HasPrefix(s, "urn:bn:") {
					m[k] = "_:" + s[7:]
				}
			} else {
				replaceURNs(v)
			}
		}
	} else if list, ok := data.([]interface{}); ok {
		for i, item := range list {
			if s, ok := item.(string); ok {
				if strings.HasPrefix(s, "urn:bn:") {
					list[i] = "_:" + s[7:]
				}
			} else {
				replaceURNs(item)
			}
		}
	}
}

func replaceLabelsWithURNs(data interface{}, labelMap map[string]string) {
	if m, ok := data.(map[string]interface{}); ok {
		for k, v := range m {
			if s, ok := v.(string); ok {
				if strings.HasPrefix(s, "_:") {
					label := s[2:]
					if hmac, ok := labelMap[label]; ok {
						m[k] = fmt.Sprintf("urn:bn:%s", hmac)
					}
				}
			} else {
				replaceLabelsWithURNs(v, labelMap)
			}
		}
	} else if list, ok := data.([]interface{}); ok {
		for i, item := range list {
			if s, ok := item.(string); ok {
				if strings.HasPrefix(s, "_:") {
					label := s[2:]
					if hmac, ok := labelMap[label]; ok {
						list[i] = fmt.Sprintf("urn:bn:%s", hmac)
					}
				}
			} else {
				replaceLabelsWithURNs(item, labelMap)
			}
		}
	}
}

func replaceURNsInNQuads(nquads string) string {
	// Replace <urn:bn:HMAC> with _:HMAC
	re := regexp.MustCompile(`<urn:bn:([^>]+)>`)
	return re.ReplaceAllString(nquads, "_:$1")
}

func removeProof(data interface{}) {
	if m, ok := data.(map[string]interface{}); ok {
		delete(m, "proof")
		delete(m, "https://w3id.org/security#proof")
		delete(m, "https://www.w3.org/ns/credentials#proof")

		for _, v := range m {
			removeProof(v)
		}
	} else if list, ok := data.([]interface{}); ok {
		for _, item := range list {
			removeProof(item)
		}
	}
}
